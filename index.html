<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ã€éº»é›€ã€‘å„ªå‹&ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆå‹ã¡ä¸ŠãŒã‚Šæ¡ä»¶è¨ˆç®—ãƒ„ãƒ¼ãƒ«</title>
  <style>
/* å…¨ä½“ã®ã‚¹ã‚¿ã‚¤ãƒ« */
/* å…¨ä½“ã®ã‚¹ã‚¿ã‚¤ãƒ« */
body {
  font-family: 'Yu Gothic UI', Arial, sans-serif;
  margin: 20px;
  background: linear-gradient(to bottom, #f5e6ff, #e6f7fa);
}
/* ã‚¿ã‚¤ãƒˆãƒ«ãƒ‡ã‚¶ã‚¤ãƒ³ */
h1 {
  padding: 0.25em;
  color: #494949;
  background: #fffaf4;
  border-left: solid 5px #ffaf58;
  border-bottom: solid 2px #dadada;
  text-align: center;
  text-shadow: 2px 2px 4px #666;
}
/* è¦‹å‡ºã—ãƒ‡ã‚¶ã‚¤ãƒ³ */
h3, h4 {
  position: relative;
  padding: 0.5rem 0.25rem;
  color: #333;
  text-shadow: 2px 2px 4px #666;
}
h3::after, h4::after {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 6px;
  content: '';
  border-radius: 3px;
  background-image: linear-gradient(to left, #ffccff 0%, #99ccff 100%);
}
/* ãƒ†ãƒ¼ãƒ–ãƒ«ãƒ‡ã‚¶ã‚¤ãƒ³ */
table {
  border-collapse: collapse;
  margin-bottom: 0.5em;
  background-color: #fff;
  box-shadow: 0 2px 5px rgba(0,0,0,0.1);
}
th, td {
  border: 1px solid #ccc;
  padding: 8px;
  text-align: center;
}
/* å…¥åŠ›è¦ç´  */
input, select {
  width: 80px;
  padding: 5px;
  border: 1px solid #ccc;
  border-radius: 4px;
}
.player-name-input {
  width: 50px;
}
/* ãã®ä»–ã®ã‚¹ã‚¿ã‚¤ãƒ« */
.error { color: #ff6347; }
.warning { color: #ffa500; }
a { text-decoration: none; color: #4682b4; }
.condition { color: #ff6347; font-size: 0.9em; cursor: pointer; }
.condition-note { color: #ff6347; font-size: 0.9em; margin-bottom: 5px; }
.input-container { display: flex; align-items: flex-start; }
.settings-container { margin-left: 10px; }
.result-container { margin-top: 10px; }

/* ãƒœã‚¿ãƒ³ã‚³ãƒ³ãƒ†ãƒŠã®ã‚¹ã‚¿ã‚¤ãƒ« */
.button-container {
  margin-top: 15px;
  display: flex;
  gap: 10px;
}

/* ãƒœã‚¿ãƒ³ã®åŸºæœ¬ãƒ‡ã‚¶ã‚¤ãƒ³ */
.button-container button {
  position: relative;
  display: inline-block;
  padding: 0.6em 1.2em;
  text-decoration: none;
  color: #333;
  background: #f0f0f0;
  border-radius: 4px;
  border: solid 1px #ccc;
  box-shadow: inset 0 2px 0 rgba(255,255,255,0.5);
  font-size: 15px;
  font-weight: bold;
  cursor: pointer;
  transition: .4s;
  overflow: hidden;
}

/* ã‚¹ãƒˆãƒ©ã‚¤ãƒ—ã®é™°å½±åŠ¹æœ */
.button-container button::before {
  content: '';
  position: absolute;
  top: 0;
  bottom: 0;
  left: -25px;
  width: 20px;
  background-image: linear-gradient(
    -45deg,
    transparent 33%,
    rgba(0, 0, 0, 0.05) 33%,
    rgba(0, 0, 0, 0.05) 66%,
    transparent 66%
  );
  background-size: 20px 20px;
  animation: stripe 3s linear infinite;
}

/* çµµæ–‡å­—ã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’.animate-emojiã‚¯ãƒ©ã‚¹ã‚’æŒã¤ãƒœã‚¿ãƒ³ã«ã®ã¿é©ç”¨ */
.button-container button.animate-emoji::after {
  content: 'ğŸ‘»';
  position: absolute;
  top: 50%;
  left: -20px;
  font-size: 16px;
  transform: translateY(-50%);
  animation: cat-emoji 3s linear infinite;
}

/* ãƒ›ãƒãƒ¼æ™‚ã®åŠ¹æœ */
.button-container button:hover {
  background-color: #e0e0e0;
  transform: translateY(1px);
}

/* ã‚¯ãƒªãƒƒã‚¯æ™‚ã®åŠ¹æœ */
.button-container button:active {
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.5);
  transform: translateY(2px);
}

/* çµµæ–‡å­—ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
@keyframes cat-emoji {
  0% {
    left: -20px;
    top: 50%;
    transform: translateY(-50%);
  }
  25% {
    left: calc(25% - 10px);
    top: 30%;
    transform: translateY(-30%);
  }
  50% {
    left: calc(50% - 10px);
    top: 70%;
    transform: translateY(-70%);
  }
  75% {
    left: calc(75% - 10px);
    top: 30%;
    transform: translateY(-30%);
  }
  100% {
    left: calc(100% + 20px);
    top: 50%;
    transform: translateY(-50%);
  }
}

/* æ¨ªä¸¦ã³ç”¨ */
.side-by-side {
  display: flex;
  align-items: flex-start;
  gap: 10px;
  margin-bottom: 10px;
}
/* ãƒ•ãƒƒã‚¿ãƒ¼ãƒ‡ã‚¶ã‚¤ãƒ³ */
footer {
  margin-top: 20px;
  padding-top: 5px;
  border-top: 1px solid #ccc;
  text-align: center;
  color: #666;
}
/* èª¬æ˜æ–‡ã®ãƒ‡ã‚¶ã‚¤ãƒ³ */
.description {
  background-color: #ffe6f0;
  padding: 8px;
  border: 1px solid #ffccff;
  border-radius: 10px;
  font-size: 1.1em;
  color: #333;
  margin-bottom: 5px;
}
#currentFinalPtTable th, #currentFinalPtTable td {
  width: 100px;
  text-align: center;
}
h2 {
  display: inline-block;
  position: relative;
  padding: 0.15em;
  background: #fffaf4;
  color: #333;
  text-shadow: 2px 2px 4px #666;
}
h2::before {
  position: absolute;
  content: '';
  top: 100%;
  left: 0;
  border: none;
  border-bottom: solid 15px transparent;
  border-right: solid 20px rgb(149, 158, 155);
}

  </style>
</head>
<body>
  <h1>ã€éº»é›€ã€‘å„ªå‹&ãƒˆãƒ¼ãƒŠãƒ¡ãƒ³ãƒˆå‹ã¡ä¸ŠãŒã‚Šæ¡ä»¶è¨ˆç®—ãƒ„ãƒ¼ãƒ«</h1>
  <div class="description">
    å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚ªãƒ¼ãƒ©ã‚¹å‰ãƒˆãƒ¼ã‚¿ãƒ«ptã¨æŒã¡ç‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚è¦ªã¯1äººã ã‘ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚<br>
    æœ¬å ´æ•°ã€ä¾›è¨—ï¼ˆ1æœ¬=1000ç‚¹ï¼‰ã€é †ä½ç‚¹ã¯å¿…è¦ã«å¿œã˜ã¦èª¿æ•´ã§ãã¾ã™ã€‚<br>
    ã€Œè¨ˆç®—ã™ã‚‹ã€ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€å„ªå‹ã™ã‚‹ãŸã‚ã®æœ€å°å’Œäº†ã‚Šç‚¹ã¨2ä½ä»¥ä¸Šã«å…¥ã‚‹ãŸã‚ã®æœ€å°å’Œäº†ã‚Šç‚¹ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚<br>
    ã€Œæ¡ä»¶ã‚ã‚Šã€ã¨è¡¨ç¤ºã•ã‚ŒãŸå ´åˆã¯ã€æ¡ä»¶é”æˆã™ã‚‹ç‚¹æ•°ã«åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚è©³ç´°ã‚’ç¢ºèªã™ã‚‹ã«ã¯ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãã ã•ã„ã€‚
  </div>
 <!-- å…¥åŠ›éƒ¨ -->
  <div class="input-container">
    <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ± -->
    <div>
      <h3>ğŸ¾ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±</h3>
      <table>
        <tr>
          <th>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</th>
          <th>ãƒˆãƒ¼ã‚¿ãƒ«pt</th>
          <th>æŒã¡ç‚¹</th>
          <th>è¦ª</th>
        </tr>
        <tr>
          <td><input type="text" id="nameA" class="player-name-input" value="A"></td>
          <td><input type="number" id="totalA" value="0" step="0.1"></td>
          <td><input type="number" id="holdA" value="25000" step="100"></td>
          <td><input type="radio" name="parent" id="parentA"></td>
        </tr>
        <tr>
          <td><input type="text" id="nameB" class="player-name-input" value="B"></td>
          <td><input type="number" id="totalB" value="0" step="0.1"></td>
          <td><input type="number" id="holdB" value="25000" step="100"></td>
          <td><input type="radio" name="parent" id="parentB"></td>
        </tr>
        <tr>
          <td><input type="text" id="nameC" class="player-name-input" value="C"></td>
          <td><input type="number" id="totalC" value="0" step="0.1"></td>
          <td><input type="number" id="holdC" value="25000" step="100"></td>
          <td><input type="radio" name="parent" id="parentC"></td>
        </tr>
        <tr>
          <td><input type="text" id="nameD" class="player-name-input" value="D"></td>
          <td><input type="number" id="totalD" value="0" step="0.1"></td>
          <td><input type="number" id="holdD" value="25000" step="100"></td>
          <td><input type="radio" name="parent" id="parentD" checked></td>
        </tr>
      </table>

      <!-- ç¾æ™‚ç‚¹æœ€çµ‚ptè¡¨ç¤ºï¼ˆæ¨ªåˆ—ï¼‰ -->
      <h4>ğŸ¾ ç¾æ™‚ç‚¹ãƒˆãƒ¼ã‚¿ãƒ«pt</h4>
      <table id="currentFinalPtTable">
        <tr>
          <th id="finalNameA"></th>
          <th id="finalNameB"></th>
          <th id="finalNameC"></th>
          <th id="finalNameD"></th>
        </tr>
        <tr>
          <td id="finalPtA"></td>
          <td id="finalPtB"></td>
          <td id="finalPtC"></td>
          <td id="finalPtD"></td>
        </tr>
      </table>
    </div>

    <!-- é †ä½ç‚¹è¨­å®š -->
    <div class="settings-container">
      <h3>ğŸ¾ é †ä½ç‚¹è¨­å®š</h3>
      <p>å„é †ä½ã®é †ä½ç‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„ï¼ˆä¾‹ï¼š1ä½:+50, 2ä½:+10, 3ä½:-10, 4ä½:-30ï¼‰</p>
      <table>
        <tr>
          <th>1ä½</th>
          <th>2ä½</th>
          <th>3ä½</th>
          <th>4ä½</th>
        </tr>
        <tr>
          <td><input type="number" id="rank1" value="50"></td>
          <td><input type="number" id="rank2" value="10"></td>
          <td><input type="number" id="rank3" value="-10"></td>
          <td><input type="number" id="rank4" value="-30"></td>
        </tr>
      </table>
      <p>æœ¬å ´æ•°: <input type="number" id="honba" value="0" min="0" step="1"> æœ¬å ´</p>
      <p>ä¾›è¨—ï¼ˆãƒªãƒ¼ãƒæ£’ï¼‰æœ¬æ•°: <input type="number" id="riichiSticks" value="0" min="0" step="1"> æœ¬ï¼ˆ1æœ¬=1000ç‚¹ï¼‰</p>
    </div>
  </div>

  <!-- ãƒœã‚¿ãƒ³ -->
  <div class="button-container">
    <button onclick="doCalculate()" class="animate-emoji">è¨ˆç®—ã™ã‚‹</button>
    <button onclick="doReset()">ãƒªã‚»ãƒƒãƒˆ</button>
    <button onclick="randomInput()">ãƒ©ãƒ³ãƒ€ãƒ å…¥åŠ›</button>
  </div>

  <!-- çµæœè¡¨ç¤º -->
  <h2>ğŸ° çµæœè¡¨ç¤º ğŸ°</h2><br>
  <p>
    å„ã‚»ãƒ«ã®ç‚¹æ•°ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€ãã®ç‚¹æ•°ã§å’Œäº†ã£ãŸå ´åˆã®ã€è©³ç´°ã€‘ãŒå³å´ã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚<br>
  </p>
  <p class="condition-note">
    â€»ã€Œæ¡ä»¶ã‚ã‚Šã€ã¨è¡¨ç¤ºã•ã‚ŒãŸå ´åˆã€è¡¨ç¤ºã•ã‚ŒãŸç‚¹æ•°ã‚ˆã‚Šé«˜ã„ç‚¹æ•°ã§ã¯æ¡ä»¶ã‚’æº€ãŸã›ãªã„ç¯„å›²ãŒã‚ã‚Šã¾ã™ã€‚<br>
    â€»ã€Œæ¡ä»¶ã‚ã‚Šã€ã‚’ã‚¯ãƒªãƒƒã‚¯ã™ã‚‹ã¨ã€OKç¯„å›²ã¨NGç¯„å›²ãŒãã‚Œãã‚Œè¡¨ç¤ºã•ã‚Œã¾ã™ã®ã§ã”ç¢ºèªãã ã•ã„ã€‚
  </p>

  <!-- winæ¡ä»¶ç”¨ï¼šå·¦å´ã«ã€å„ªå‹ã™ã‚‹ãŸã‚ã®æœ€å°å’Œäº†ç‚¹æ•°ã€‘ã¨å³å´ã«ã€è©³ç´°ã€‘ -->
  <div class="result-container">
    <div class="side-by-side">
      <div id="resultArea"></div>
      <div id="detailArea"></div>
    </div>
    <!-- 2ä½ä»¥å†…æ¡ä»¶ç”¨ï¼šå·¦å´ã«ã€2ä½ä»¥å†…ã«å…¥ã‚‹ãŸã‚ã®æœ€å°å’Œäº†ç‚¹æ•°ã€‘ã¨å³å´ã«ã€ç¯„å›²è©³ç´°ã€‘ -->
    <div class="side-by-side">
      <div id="top2Area"></div>
      <div id="rangeDetail"></div>
    </div>
  </div>

  <!-- ãƒ•ãƒƒã‚¿ãƒ¼ -->
  <footer>
    <p>ä¸å…·åˆã®ã”å ±å‘Šãƒ»ãŠå•ã„åˆã‚ã›: 
      <a href="mailto:hirokuni.akiyama.npm@gmail.com" aria-label="ãƒ¡ãƒ¼ãƒ«é€ä¿¡" title="hirokuni.akiyama.npm@gmail.com">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
          <rect x="2" y="4" width="20" height="16" rx="2" />
          <path d="M22 7l-10 7L2 7" />
        </svg>
      </a>
      ã¾ãŸã¯
      <a href="https://x.com/HirokuniAkiyama" target="_blank" rel="noopener noreferrer" aria-label="X (æ—§Twitter)" title="X (æ—§Twitter) ã§ãŠå•ã„åˆã‚ã›">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16" fill="currentColor" style="vertical-align: middle;">
          <path d="M18.244 2.25h4.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
        </svg>
      </a>
    </p>
    <p>Â©2025 hirokuni.akiyama</p>
  </footer>

  <script>
    // å„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åãƒ»é †ä½ç‚¹ã®å–å¾—
    function getPlayerNames() {
      return {
        A: document.getElementById("nameA").value || "A",
        B: document.getElementById("nameB").value || "B",
        C: document.getElementById("nameC").value || "C",
        D: document.getElementById("nameD").value || "D"
      };
    }

    function getRankPoints() {
      return [
        parseFloat(document.getElementById("rank1").value),
        parseFloat(document.getElementById("rank2").value),
        parseFloat(document.getElementById("rank3").value),
        parseFloat(document.getElementById("rank4").value)
      ];
    }

    // å’Œäº†ç‚¹ã®å®šæ•°ï¼ˆè¦ªãƒ»å­ã®ãƒ­ãƒ³ï¼ãƒ„ãƒ¢ç‚¹æ•°ï¼‰
    const PARENT_RON_POINTS = [1500, 2000, 2400, 2900, 3400, 3900, 4400, 4800, 5300, 5800, 6800, 7700, 8700, 9600, 10600, 11600, 12000, 18000, 24000, 36000, 48000, 96000, 144000];
    const PARENT_TSUMO_POINTS = [500, 700, 800, 1000, 1200, 1300, 1500, 1600, 1800, 2000, 2300, 2600, 2900, 3200, 3600, 3900, 4000, 6000, 8000, 12000, 16000, 32000, 48000];
    const CHILD_RON_POINTS  = [1000, 1300, 1600, 2000, 2300, 2600, 2900, 3200, 3600, 3900, 4500, 5200, 5800, 6400, 7100, 7700, 8000, 12000, 16000, 24000, 32000, 64000, 96000];
    const CHILD_TSUMO_POINTS = [
      [300, 500], [400, 700], [400, 800], [500, 1000], [600, 1200], [700, 1300],
      [800, 1500], [800, 1600], [900, 1800], [1000, 2000], [1200, 2300], [1300, 2600],
      [1500, 2900], [1600, 3200], [1800, 3600], [2000, 3900], [2000, 4000],
      [3000, 6000], [4000, 8000], [6000, 12000], [8000, 16000], [16000, 32000], [24000, 48000]
    ];

    function calcFinalTotals(modHoldings, totals, rankPoints) {
      let playerNames = getPlayerNames();
      let players = ["A", "B", "C", "D"].map(p => {
        return { 
          key: p, 
          name: playerNames[p], 
          hold: modHoldings[p], 
          totalBefore: totals[p]
        };
      });
      players.sort((a, b) => b.hold - a.hold);
      let currentRank = 1;
      for (let i = 0; i < players.length;) {
        let group = [players[i]];
        let j = i + 1;
        while (j < players.length && players[j].hold === players[i].hold) {
          group.push(players[j]);
          j++;
        }
        let groupSize = group.length;
        let sumRankPoints = 0;
        for (let k = 0; k < groupSize; k++) {
          sumRankPoints += rankPoints[currentRank - 1 + k];
        }
        let avgRankPoint = sumRankPoints / groupSize;
        group.forEach(player => {
          player.diff = (player.hold - 30000) / 1000;
          player.rank = currentRank;
          player.rankPoint = avgRankPoint;
          player.final = player.totalBefore + player.diff + player.rankPoint;
        });
        currentRank += groupSize;
        i = j;
      }
      return players;
    }

    function getMinPoints(totals, holds, winner, method, target, parentFlags, honba, riichiSticks, isWin) {
      let pointsList;
      if (method === "ron") {
        pointsList = parentFlags[winner] ? PARENT_RON_POINTS : CHILD_RON_POINTS;
        pointsList = [0, ...pointsList];
      } else if (method === "tsumo") {
        if (parentFlags[winner]) {
          pointsList = [0, ...PARENT_TSUMO_POINTS];
        } else {
          pointsList = [[0, 0], ...CHILD_TSUMO_POINTS];
        }
      }
      let minPoint = null;
      for (let point of pointsList) {
        let X, Y;
        if (method === "tsumo" && !parentFlags[winner]) {
          X = point[0];
          Y = point[1];
        } else {
          X = point;
        }
        let newHolds = Object.assign({}, holds);
        if (method === "ron") {
          if (X > 0) {
            let ronPoints = X + honba * 300;
            newHolds[winner] += ronPoints;
            newHolds[target] -= ronPoints;
            newHolds[winner] += riichiSticks * 1000;
          }
        } else if (method === "tsumo") {
          if ((parentFlags[winner] && X > 0) || (!parentFlags[winner] && (X > 0 || Y > 0))) {
            if (parentFlags[winner]) {
              let tsumoPoints = X + honba * 100;
              newHolds[winner] += tsumoPoints * 3;
              ["A", "B", "C", "D"].forEach(p => {
                if (p !== winner) newHolds[p] -= tsumoPoints;
              });
            } else {
              let childPay = X + honba * 100;
              let parentPay = Y + honba * 100;
              let parent = Object.entries(parentFlags).find(([k, v]) => v)[0];
              newHolds[winner] += childPay * 2 + parentPay;
              ["A", "B", "C", "D"].forEach(p => {
                if (p !== winner) {
                  if (p === parent) newHolds[p] -= parentPay;
                  else newHolds[p] -= childPay;
                }
              });
            }
            newHolds[winner] += riichiSticks * 1000;
          }
        }
        let players = calcFinalTotals(newHolds, totals, getRankPoints());
        let winFinal = players.find(p => p.key === winner).final;
        let conditionMet = isWin 
          ? players.every(p => p.key === winner || p.final < winFinal)
          : players.filter(p => p.key !== winner && p.final < winFinal).length >= 2;
        if (conditionMet) {
          minPoint = method === "tsumo" && !parentFlags[winner] 
            ? (X === 0 && Y === 0 ? "ã‚ªãƒ¼ãƒ«OK" : `${X} / ${Y}`) 
            : (X === 0 ? "ã‚ªãƒ¼ãƒ«OK" : X);
          break;
        }
      }
      return minPoint === null ? (isWin ? "å„ªå‹ä¸å¯" : "2ä½ä»¥å†…ä¸å¯") : minPoint;
    }

    function getWinningRanges(totals, holds, winner, method, target, parentFlags, honba, riichiSticks, isWin) {
      let pointsList;
      if (method === "ron") {
        pointsList = parentFlags[winner] ? PARENT_RON_POINTS : CHILD_RON_POINTS;
        pointsList = [0, ...pointsList];
      } else if (method === "tsumo") {
        if (parentFlags[winner]) {
          pointsList = [0, ...PARENT_TSUMO_POINTS];
        } else {
          pointsList = [[0, 0], ...CHILD_TSUMO_POINTS];
        }
      }
      let ranges = { ok: [], ng: [] };
      let prevConditionMet = false;
      let currentRange = null;
      for (let i = 0; i < pointsList.length; i++) {
        let point = pointsList[i];
        let X, Y;
        if (method === "tsumo" && !parentFlags[winner]) {
          X = point[0];
          Y = point[1];
        } else {
          X = point;
        }
        let newHolds = Object.assign({}, holds);
        if (method === "ron") {
          if (X > 0) {
            let ronPoints = X + honba * 300;
            newHolds[winner] += ronPoints;
            newHolds[target] -= ronPoints;
            newHolds[winner] += riichiSticks * 1000;
          }
        } else if (method === "tsumo") {
          if ((parentFlags[winner] && X > 0) || (!parentFlags[winner] && (X > 0 || Y > 0))) {
            if (parentFlags[winner]) {
              let tsumoPoints = X + honba * 100;
              newHolds[winner] += tsumoPoints * 3;
              ["A", "B", "C", "D"].forEach(p => {
                if (p !== winner) newHolds[p] -= tsumoPoints;
              });
            } else {
              let childPay = X + honba * 100;
              let parentPay = Y + honba * 100;
              let parent = Object.entries(parentFlags).find(([k, v]) => v)[0];
              newHolds[winner] += childPay * 2 + parentPay;
              ["A", "B", "C", "D"].forEach(p => {
                if (p !== winner) {
                  if (p === parent) newHolds[p] -= parentPay;
                  else newHolds[p] -= childPay;
                }
              });
            }
            newHolds[winner] += riichiSticks * 1000;
          }
        }
        let players = calcFinalTotals(newHolds, totals, getRankPoints());
        let winFinal = players.find(p => p.key === winner).final;
        let conditionMet = isWin 
          ? players.every(p => p.key === winner || p.final < winFinal)
          : players.filter(p => p.key !== winner && p.final < winFinal).length >= 2;
        let pointStr = method === "tsumo" && !parentFlags[winner] ? `${X} / ${Y}` : `${X}`;
        if (conditionMet !== prevConditionMet) {
          if (currentRange) {
            currentRange.end = i > 0 ? (method === "tsumo" && !parentFlags[winner] 
              ? `${pointsList[i-1][0]} / ${pointsList[i-1][1]}` 
              : `${pointsList[i-1]}`) : pointStr;
            ranges[prevConditionMet ? "ok" : "ng"].push(currentRange);
          }
          currentRange = { start: pointStr };
          prevConditionMet = conditionMet;
        }
      }
      if (currentRange) {
        currentRange.end = method === "tsumo" && !parentFlags[winner] 
          ? `${pointsList[pointsList.length-1][0]} / ${pointsList[pointsList.length-1][1]}`
          : `${pointsList[pointsList.length-1]}`;
        ranges[prevConditionMet ? "ok" : "ng"].push(currentRange);
      }
      return ranges;
    }

    function formatRanges(ranges) {
      let okStr = ranges.ok.length > 0 
        ? ranges.ok.map(r => r.start === r.end ? r.start : `${r.start} ï½ ${r.end}`).join(", ")
        : "ãªã—";
      let ngStr = ranges.ng.length > 0 
        ? ranges.ng.map(r => r.start === r.end ? r.start : `${r.start} ï½ ${r.end}`).join(", ")
        : "ãªã—";
      return `<table><tr><th>OKç¯„å›²</th><th>NGç¯„å›²</th></tr><tr><td>${okStr}</td><td>${ngStr}</td></tr></table>`;
    }

    function simulateScenario(winner, method, target, scoreVal, totals, holds, parentFlags, honba, riichiSticks, rankPoints) {
      let newHolds = Object.assign({}, holds);
      let X, Y;
      if (method === "ron") {
        X = Number(scoreVal);
        if (X > 0) {
          let ronPoints = X + honba * 300;
          newHolds[winner] += ronPoints;
          newHolds[target] -= ronPoints;
          newHolds[winner] += riichiSticks * 1000;
        }
      } else if (method === "tsumo") {
        if (parentFlags[winner]) {
          X = Number(scoreVal);
          if (X > 0) {
            let tsumoPoints = X + honba * 100;
            newHolds[winner] += tsumoPoints * 3;
            ["A", "B", "C", "D"].forEach(p => {
              if (p !== winner) newHolds[p] -= tsumoPoints;
            });
            newHolds[winner] += riichiSticks * 1000;
          }
        } else {
          let parts = scoreVal.split("/");
          X = Number(parts[0].trim());
          Y = Number(parts[1].trim());
          if (X > 0 || Y > 0) {
            let childPay = X + honba * 100;
            let parentPay = Y + honba * 100;
            let parent = Object.entries(parentFlags).find(([k, v]) => v)[0];
            newHolds[winner] += childPay * 2 + parentPay;
            ["A", "B", "C", "D"].forEach(p => {
              if (p !== winner) {
                if (p === parent) newHolds[p] -= parentPay;
                else newHolds[p] -= childPay;
              }
            });
            newHolds[winner] += riichiSticks * 1000;
          }
        }
      }
      return calcFinalTotals(newHolds, totals, rankPoints);
    }

    function showDetail(winnerKey, method, targetKey, scoreVal) {
      let playerNames = getPlayerNames();
      let winner = playerNames[winnerKey];
      let target = targetKey ? playerNames[targetKey] : "";
      
      let totals = {
        A: parseFloat(document.getElementById("totalA").value),
        B: parseFloat(document.getElementById("totalB").value),
        C: parseFloat(document.getElementById("totalC").value),
        D: parseFloat(document.getElementById("totalD").value)
      };
      let holds = {
        A: parseInt(document.getElementById("holdA").value),
        B: parseInt(document.getElementById("holdB").value),
        C: parseInt(document.getElementById("holdC").value),
        D: parseInt(document.getElementById("holdD").value)
      };
      let parentFlags = {
        A: document.getElementById("parentA").checked,
        B: document.getElementById("parentB").checked,
        C: document.getElementById("parentC").checked,
        D: document.getElementById("parentD").checked
      };
      let honba = parseInt(document.getElementById("honba").value);
      let riichiSticks = parseInt(document.getElementById("riichiSticks").value);
      let rankPoints = getRankPoints();
      let players = simulateScenario(winnerKey, method, targetKey, scoreVal, totals, holds, parentFlags, honba, riichiSticks, rankPoints);
      let detailHtml = "<h4>ğŸ¾ ã€è©³ç´°ã€‘" + winner + "ãŒ" + (method === "ron" ? ("ãƒ­ãƒ³ from " + target) : "ãƒ„ãƒ¢") + "ã§" + scoreVal + "ç‚¹å’Œäº†ã£ãŸå ´åˆ</h4>";
      detailHtml += "<table><tr><th>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</th><th>æ–°æŒã¡ç‚¹</th><th>æŒã¡ç‚¹å·®</th><th>é †ä½ç‚¹</th><th>åŠè˜å¾—å¤±ç‚¹</th><th>å‰å›ãƒˆãƒ¼ã‚¿ãƒ«pt</th><th>åˆè¨ˆ</th></tr>";
      players.sort((a, b) => a.key.localeCompare(b.key));
      players.forEach(p => {
        let diff = ((p.hold - 30000) / 1000).toFixed(1);
        detailHtml += `<tr>
          <td>${p.name}</td>
          <td>${p.hold}</td>
          <td>${diff}</td>
          <td>${p.rankPoint.toFixed(1)}</td>
          <td>${(p.diff + p.rankPoint).toFixed(1)}</td>
          <td>${p.totalBefore}</td>
          <td>${p.final.toFixed(1)}</td>
        </tr>`;
      });
      detailHtml += "</table>";
      document.getElementById("detailArea").innerHTML = detailHtml;
    }

    function showRangeDetail(winnerKey, method, targetKey, isWin) {
      let playerNames = getPlayerNames();
      let totals = {
        A: parseFloat(document.getElementById("totalA").value),
        B: parseFloat(document.getElementById("totalB").value),
        C: parseFloat(document.getElementById("totalC").value),
        D: parseFloat(document.getElementById("totalD").value)
      };
      let holds = {
        A: parseInt(document.getElementById("holdA").value),
        B: parseInt(document.getElementById("holdB").value),
        C: parseInt(document.getElementById("holdC").value),
        D: parseInt(document.getElementById("holdD").value)
      };
      let parentFlags = {
        A: document.getElementById("parentA").checked,
        B: document.getElementById("parentB").checked,
        C: document.getElementById("parentC").checked,
        D: document.getElementById("parentD").checked
      };
      let honba = parseInt(document.getElementById("honba").value);
      let riichiSticks = parseInt(document.getElementById("riichiSticks").value);
      let ranges = getWinningRanges(totals, holds, winnerKey, method, targetKey, parentFlags, honba, riichiSticks, isWin);
      let rangeText = formatRanges(ranges);
      let targetText = targetKey ? `ãƒ­ãƒ³ from ${playerNames[targetKey]}` : "ãƒ„ãƒ¢";
      let detailHtml = `<h4>ğŸ¾ ã€ç¯„å›²è©³ç´°ã€‘${playerNames[winnerKey]}ãŒ${targetText}ã§${isWin ? "å„ªå‹" : "2ä½ä»¥å†…"}ã«ãªã‚‹å ´åˆ</h4>`;
      detailHtml += rangeText;
      document.getElementById("rangeDetail").innerHTML = detailHtml;
    }

    function doCalculate() {
      let playerNames = getPlayerNames();
      let totals = {
        A: parseFloat(document.getElementById("totalA").value),
        B: parseFloat(document.getElementById("totalB").value),
        C: parseFloat(document.getElementById("totalC").value),
        D: parseFloat(document.getElementById("totalD").value)
      };
      let holds = {
        A: parseInt(document.getElementById("holdA").value),
        B: parseInt(document.getElementById("holdB").value),
        C: parseInt(document.getElementById("holdC").value),
        D: parseInt(document.getElementById("holdD").value)
      };
      let parentFlags = {
        A: document.getElementById("parentA").checked,
        B: document.getElementById("parentB").checked,
        C: document.getElementById("parentC").checked,
        D: document.getElementById("parentD").checked
      };
      let honba = parseInt(document.getElementById("honba").value);
      let riichiSticks = parseInt(document.getElementById("riichiSticks").value);
      let rankPoints = getRankPoints();
      let errorMessages = "";
      let totalSum = Object.values(totals).reduce((a, b) => a + b, 0);
      if (Math.abs(totalSum) > 0.0001) {
        errorMessages += `<p class="warning">è­¦å‘Šï¼šãƒˆãƒ¼ã‚¿ãƒ«ãƒã‚¤ãƒ³ãƒˆã®åˆè¨ˆãŒ0ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆåˆè¨ˆ: ${totalSum.toFixed(2)}ï¼‰ã€‚</p>`;
      }
      let holdSum = Object.values(holds).reduce((a, b) => a + b, 0);
      if (holdSum + riichiSticks * 1000 !== 100000) {
        errorMessages += `<p class="warning">è­¦å‘Šï¼šæŒã¡ç‚¹ã®åˆè¨ˆãŒ100,000ç‚¹ã§ã¯ã‚ã‚Šã¾ã›ã‚“ï¼ˆåˆè¨ˆ: ${holdSum + riichiSticks * 1000}ï¼‰ã€‚</p>`;
      }
      let pCount = Object.values(parentFlags).filter(v => v).length;
      if (pCount !== 1) {
        errorMessages += `<p class="error">ã‚¨ãƒ©ãƒ¼ï¼šè¦ªã¯å¿…ãš1äººã ã‘ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼ˆç¾åœ¨ ${pCount} äººï¼‰ã€‚</p>`;
        document.getElementById("resultArea").innerHTML = errorMessages;
        return;
      }
      let players = ["A", "B", "C", "D"];
      let winResults = {};
      players.forEach(w => {
        winResults[w] = { ron: {}, tsumo: null };
        players.forEach(l => {
          if (l !== w) {
            let minPoint = getMinPoints(totals, holds, w, "ron", l, parentFlags, honba, riichiSticks, true);
            let ranges = getWinningRanges(totals, holds, w, "ron", l, parentFlags, honba, riichiSticks, true);
            let hasCondition = ranges.ng.length > 0; // NGç¯„å›²ãŒå­˜åœ¨ã™ã‚‹ã‹
            winResults[w].ron[l] = minPoint === "å„ªå‹ä¸å¯"
              ? minPoint
              : (minPoint === "ã‚ªãƒ¼ãƒ«OK"
                ? (hasCondition
                  ? `ã‚ªãƒ¼ãƒ«OK <span class="condition" onclick="showRangeDetail('${w}', 'ron', '${l}', true)">â€»æ¡ä»¶ã‚ã‚Š</span>`
                  : minPoint)
                : `<a href="javascript:void(0)" onclick="showDetail('${w}', 'ron', '${l}', '${minPoint}')">${minPoint}ç‚¹</a>` +
                  (hasCondition ? ` <span class="condition" onclick="showRangeDetail('${w}', 'ron', '${l}', true)">æ¡ä»¶ã‚ã‚Š</span>` : ""));
          }
        });
        let minTsumo = getMinPoints(totals, holds, w, "tsumo", "", parentFlags, honba, riichiSticks, true);
        let rangesTsumo = getWinningRanges(totals, holds, w, "tsumo", "", parentFlags, honba, riichiSticks, true);
        let hasTsumoCondition = rangesTsumo.ng.length > 0;
        winResults[w].tsumo = minTsumo === "å„ªå‹ä¸å¯"
          ? minTsumo
          : (minTsumo === "ã‚ªãƒ¼ãƒ«OK"
            ? (hasTsumoCondition
              ? `ã‚ªãƒ¼ãƒ«OK <span class="condition" onclick="showRangeDetail('${w}', 'tsumo', '', true)">â€»æ¡ä»¶ã‚ã‚Š</span>`
              : minTsumo)
            : `<a href="javascript:void(0)" onclick="showDetail('${w}', 'tsumo', '', '${minTsumo}')">${minTsumo}</a>` +
              (hasTsumoCondition ? ` <span class="condition" onclick="showRangeDetail('${w}', 'tsumo', '', true)">æ¡ä»¶ã‚ã‚Š</span>` : ""));
      });

      let top2Results = {};
      players.forEach(w => {
        top2Results[w] = { ron: {}, tsumo: null };
        players.forEach(l => {
          if (l !== w) {
            let minPoint = getMinPoints(totals, holds, w, "ron", l, parentFlags, honba, riichiSticks, false);
            let ranges = getWinningRanges(totals, holds, w, "ron", l, parentFlags, honba, riichiSticks, false);
            let hasCondition = ranges.ng.length > 0;
            top2Results[w].ron[l] = minPoint === "2ä½ä»¥å†…ä¸å¯"
              ? minPoint
              : (minPoint === "ã‚ªãƒ¼ãƒ«OK"
                ? (hasCondition
                  ? `ã‚ªãƒ¼ãƒ«OK <span class="condition" onclick="showRangeDetail('${w}', 'ron', '${l}', false)">â€»æ¡ä»¶ã‚ã‚Š</span>`
                  : minPoint)
                : `<a href="javascript:void(0)" onclick="showDetail('${w}', 'ron', '${l}', '${minPoint}')">${minPoint}ç‚¹</a>` +
                  (hasCondition ? ` <span class="condition" onclick="showRangeDetail('${w}', 'ron', '${l}', false)">æ¡ä»¶ã‚ã‚Š</span>` : ""));
          }
        });
        let minTsumo = getMinPoints(totals, holds, w, "tsumo", "", parentFlags, honba, riichiSticks, false);
        let rangesTsumo = getWinningRanges(totals, holds, w, "tsumo", "", parentFlags, honba, riichiSticks, false);
        let hasTsumoCondition = rangesTsumo.ng.length > 0;
        top2Results[w].tsumo = minTsumo === "2ä½ä»¥å†…ä¸å¯"
          ? minTsumo
          : (minTsumo === "ã‚ªãƒ¼ãƒ«OK"
            ? (hasTsumoCondition
              ? `ã‚ªãƒ¼ãƒ«OK <span class="condition" onclick="showRangeDetail('${w}', 'tsumo', '', false)">â€»æ¡ä»¶ã‚ã‚Š</span>`
              : minTsumo)
            : `<a href="javascript:void(0)" onclick="showDetail('${w}', 'tsumo', '', '${minTsumo}')">${minTsumo}</a>` +
              (hasTsumoCondition ? ` <span class="condition" onclick="showRangeDetail('${w}', 'tsumo', '', false)">æ¡ä»¶ã‚ã‚Š</span>` : ""));
      });

      let winHtml = "<h4>ğŸ¾ å„ªå‹ã™ã‚‹ãŸã‚ã«å¿…è¦ãªæœ€å°å’Œäº†ç‚¹æ•°</h4><table class='resultTable'><tr><th>å’Œäº†è€…</th>";
      players.forEach(p => winHtml += `<th>ãƒ­ãƒ³ from ${playerNames[p]}</th>`);
      winHtml += "<th>ãƒ„ãƒ¢</th></tr>";
      players.forEach(w => {
        winHtml += `<tr><th>${playerNames[w]}</th>`;
        players.forEach(p => {
          winHtml += p === w ? "<td>â€•</td>" : `<td>${winResults[w].ron[p]}</td>`;
        });
        winHtml += `<td>${winResults[w].tsumo}</td></tr>`;
      });
      winHtml += "</table>";

      let top2Html = "<h4>ğŸ¾ 2ä½ä»¥å†…ã«å…¥ã‚‹ãŸã‚ã«å¿…è¦ãªæœ€å°å’Œäº†ç‚¹æ•°</h4><table class='resultTable'><tr><th>å’Œäº†è€…</th>";
      players.forEach(p => top2Html += `<th>ãƒ­ãƒ³ from ${playerNames[p]}</th>`);
      top2Html += "<th>ãƒ„ãƒ¢</th></tr>";
      players.forEach(w => {
        top2Html += `<tr><th>${playerNames[w]}</th>`;
        players.forEach(p => {
          top2Html += p === w ? "<td>â€•</td>" : `<td>${top2Results[w].ron[p]}</td>`;
        });
        top2Html += `<td>${top2Results[w].tsumo}</td></tr>`;
      });
      top2Html += "</table>";

      document.getElementById("resultArea").innerHTML = errorMessages + winHtml;
      document.getElementById("top2Area").innerHTML = top2Html;
    }

function doReset() {
      document.getElementById("nameA").value = "A";
      document.getElementById("nameB").value = "B";
      document.getElementById("nameC").value = "C";
      document.getElementById("nameD").value = "D";
      document.getElementById("totalA").value = "0";
      document.getElementById("totalB").value = "0";
      document.getElementById("totalC").value = "0";
      document.getElementById("totalD").value = "0";
      document.getElementById("holdA").value = "25000";
      document.getElementById("holdB").value = "25000";
      document.getElementById("holdC").value = "25000";
      document.getElementById("holdD").value = "25000";
      document.getElementById("parentA").checked = false;
      document.getElementById("parentB").checked = false;
      document.getElementById("parentC").checked = false;
      document.getElementById("parentD").checked = true;
      document.getElementById("rank1").value = "50";
      document.getElementById("rank2").value = "10";
      document.getElementById("rank3").value = "-10";
      document.getElementById("rank4").value = "-30";
      document.getElementById("honba").value = "0";
      document.getElementById("riichiSticks").value = "0";
      document.getElementById("resultArea").innerHTML = "";
      document.getElementById("top2Area").innerHTML = "";
      document.getElementById("detailArea").innerHTML = "";
      document.getElementById("rangeDetail").innerHTML = "";
      
      // ç¾æ™‚ç‚¹ãƒˆãƒ¼ã‚¿ãƒ«ptã®è¡¨ç¤ºã‚’æ›´æ–°
      updateFinalPts();
    }

// ãƒ©ãƒ³ãƒ€ãƒ å…¥åŠ›é–¢æ•°
function randomInput() {
  const players = ["A", "B", "C", "D"];
  
  // ãƒˆãƒ¼ã‚¿ãƒ«ptã®ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆï¼ˆã‚ˆã‚Šç‹­ã„ç¯„å›²ã§ï¼š-50ã€œ50ã€åˆè¨ˆ0ï¼‰
  let totals = [];
  for (let i = 0; i < 3; i++) {
    totals.push(parseFloat((Math.random() * 100 - 50).toFixed(1)));
  }
  // æœ€å¾Œã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆè¨ˆã‚’ç›¸æ®ºã™ã‚‹å€¤ã«ã™ã‚‹
  const totalSum = totals.reduce((sum, val) => sum + val, 0);
  totals.push(parseFloat((-totalSum).toFixed(1)));
  
  // æŒã¡ç‚¹ã®ãƒ©ãƒ³ãƒ€ãƒ ç”Ÿæˆï¼ˆã‚ˆã‚Šç¾å®Ÿçš„ãªç¯„å›²ã«ï¼‰
  // ãƒªãƒ¼ãƒæ£’ï¼ˆä¾›è¨—ï¼‰ã‚’ã¾ãšæ±ºã‚ã‚‹ï¼ˆ0ã€œ3æœ¬ï¼‰
  const riichiSticks = Math.floor(Math.random() * 4);
  const riichiPoints = riichiSticks * 1000;
  
  // é…åˆ†ã™ã‚‹æŒã¡ç‚¹ã®åˆè¨ˆï¼ˆ100000 - ãƒªãƒ¼ãƒæ£’åˆ†ï¼‰
  const totalHoldPoints = 100000 - riichiPoints;
  
  // åŸºæº–ç‚¹ï¼ˆé€šå¸¸ã¯25000ç‚¹ï¼‰
  const basePoints = 25000;
  
  // æœ€åˆã®3äººã®æŒã¡ç‚¹ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ç”Ÿæˆï¼ˆã‚ˆã‚Šç‹­ã„ç¯„å›²ã§ï¼šåŸºæº–ç‚¹Â±10000ç‚¹ã€100ç‚¹å˜ä½ï¼‰
  let holds = [];
  let remainingPoints = totalHoldPoints;
  
  for (let i = 0; i < 3; i++) {
    // æ®‹ã‚Šã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚‚ååˆ†ãªç‚¹æ•°ã‚’æ®‹ã™ã‚ˆã†èª¿æ•´
    const averageRemaining = remainingPoints / (4 - i);
    const minHold = Math.max(basePoints - 10000, averageRemaining - 15000);
    const maxHold = Math.min(basePoints + 10000, averageRemaining + 15000);
    
    // ç¯„å›²å†…ã§ãƒ©ãƒ³ãƒ€ãƒ ãªå€¤ã‚’ç”Ÿæˆã—ã€100ç‚¹å˜ä½ã«ä¸¸ã‚ã‚‹
    const playerHold = Math.floor((Math.random() * (maxHold - minHold) + minHold) / 100) * 100;
    holds.push(playerHold);
    remainingPoints -= playerHold;
  }
  
  // æœ€å¾Œã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯æ®‹ã‚Šã®ç‚¹æ•°ã‚’å‰²ã‚Šå½“ã¦ã¦åˆè¨ˆã‚’ãƒ”ãƒƒã‚¿ãƒªåˆã‚ã›ã‚‹
  holds.push(remainingPoints);
  
  // æœ¬å ´æ•°ï¼ˆ0ã€œ5ï¼‰
  const honba = Math.floor(Math.random() * 6);
  
  // è¦ªã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸æŠ
  const parentIndex = Math.floor(Math.random() * 4);
  const parent = players[parentIndex];
  
  // å…¥åŠ›æ¬„ã«å€¤ã‚’è¨­å®š
  players.forEach((p, i) => {
    document.getElementById(`total${p}`).value = totals[i];
    document.getElementById(`hold${p}`).value = holds[i];
    document.getElementById(`parent${p}`).checked = (p === parent);
  });
  document.getElementById("honba").value = honba;
  document.getElementById("riichiSticks").value = riichiSticks;
  
  // ç¾æ™‚ç‚¹ãƒˆãƒ¼ã‚¿ãƒ«ptã‚’æ›´æ–°
  updateFinalPts();
}

    // åˆæœŸæŒã¡ç‚¹ï¼ˆé€šå¸¸30000ç‚¹ï¼‰
    const INITIAL_HOLD = 30000;

    // æœ€çµ‚ptè¡¨ç¤ºæ›´æ–°ç”¨ã®é–¢æ•°
    function updateFinalPts() {
      const players = ["A", "B", "C", "D"];
      const totals = players.map(p => parseFloat(document.getElementById(`total${p}`).value) || 0);
      const holds = players.map(p => {
        const holdValue = document.getElementById(`hold${p}`).value;
        return holdValue === "" ? INITIAL_HOLD : parseInt(holdValue);
      });
      const rankPoints = [
        parseFloat(document.getElementById("rank1").value) || 50,
        parseFloat(document.getElementById("rank2").value) || 10,
        parseFloat(document.getElementById("rank3").value) || -10,
        parseFloat(document.getElementById("rank4").value) || -30
      ];
      const holdRanks = players.map((p, i) => ({ key: p, hold: holds[i] }));
      holdRanks.sort((a, b) => b.hold - a.hold);
      let rank = 1;
      for (let i = 0; i < holdRanks.length; ) {
        let group = [holdRanks[i]];
        let j = i + 1;
        while (j < holdRanks.length && holdRanks[j].hold === holdRanks[i].hold) {
          group.push(holdRanks[j]);
          j++;
        }
        const groupSize = group.length;
        const sumRankPoints = rankPoints.slice(rank - 1, rank - 1 + groupSize).reduce((a, b) => a + b, 0);
        const avgRankPoint = sumRankPoints / groupSize;
        group.forEach(player => { player.rankPoint = avgRankPoint; });
        rank += groupSize;
        i = j;
      }
      const finalPts = players.map((p, i) => {
        const holdDiff = (holds[i] - INITIAL_HOLD) / 1000;
        const rankPoint = holdRanks.find(r => r.key === p).rankPoint;
        return totals[i] + holdDiff + rankPoint;
      });
      players.forEach((p, i) => {
        const name = document.getElementById(`name${p}`).value || p;
        document.getElementById(`finalName${p}`).textContent = name;
        document.getElementById(`finalPt${p}`).textContent = finalPts[i].toFixed(1);
      });
    }

    // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼è¨­å®š
    document.querySelectorAll('input[id^=name], input[id^=total], input[id^=hold], input[id^=rank]').forEach(input => {
      input.addEventListener('input', updateFinalPts);
    });

    updateFinalPts();
  </script>
</body>
</html>
