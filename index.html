<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>【麻雀】優勝&トーナメント勝ち上がり条件計算ツール</title>
  <style>
    /* 全体のスタイル */
    body {
      font-family: 'MS Sans Serif', Arial, sans-serif;
      margin: 20px;
      background: linear-gradient(to bottom, #f5e6ff, #e6f7fa);
    }

    /* タイトルデザイン */
    h1 {
      padding: 0.5em;
      color: #494949;
      background: #fffaf4;
      border-left: solid 5px #ffaf58;
      border-bottom: solid 2px #dadada;
      text-align: center;
      text-shadow: 2px 2px 4px #666; /* ①ドロップシャドウを追加 */
    }

    /* 見出しデザイン */
    h2, h3 {
      position: relative;
      padding: 1rem 0.5rem;
      color: #333;
      text-shadow: 2px 2px 4px #666; /* ①ドロップシャドウを追加 */
    }
    h2::after, h3::after {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 6px;
      content: '';
      border-radius: 3px;
      background-image: linear-gradient(to left, #ffccff 0%, #99ccff 100%);
    }

    /* テーブルデザイン */
    table {
      border-collapse: collapse;
      margin-bottom: 1em;
      background-color: #fff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    th, td {
      border: 1px solid #ccc;
      padding: 8px;
      text-align: center;
    }

    /* 入力要素 */
    input, select {
      width: 80px;
      padding: 5px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .player-name-input {
      width: 50px;
    }

    /* その他のスタイル */
    .error { color: #ff6347; }
    .warning { color: #ffa500; }
    a { text-decoration: none; color: #4682b4; }
    .input-container { display: flex; align-items: flex-start; }
    .settings-container { margin-left: 20px; }
    .result-container { display: flex; align-items: flex-start; }
    #detailArea { margin-left: 20px; }
    .button-container { margin-top: 20px; }

    /* フッターデザイン */
    footer {
      margin-top: 40px;
      padding-top: 10px;
      border-top: 1px solid #ccc;
      text-align: center;
      color: #666;
    }

    /* 説明文のデザイン（②目立たせる工夫） */
    .description {
      background-color: #ffe6f0; /* 薄いピンクの背景 */
      padding: 15px;
      border: 1px solid #ffccff; /* 柔らかいピンクのボーダー */
      border-radius: 10px; /* 角を丸く */
      font-size: 1.1em; /* 文字サイズを少し大きく */
      color: #333; /* 濃いグレーで視認性向上 */
      margin-bottom: 20px; /* 下に余白 */
    }
  </style>
</head>
<body>
  <h1>【麻雀】優勝&トーナメント勝ち上がり条件計算ツール</h1>
  <div class="description">
    各プレイヤーのオーラス前トータルptと持ち点（点）を入力し、親を1人だけチェックしてください。<br>
    本場数、供託（1本=1000点）、順位点は必要に応じて入力してください。<br>
    必要事項入力後「計算する」ボタンをクリックすると、<br>
    オーラスに優勝する為の最小和了り点と2位以上になる為の最小和了り点一覧が表示されます(多分)。
  </div>

  <!-- 入力部 -->
  <div class="input-container">
    <div>
      <h2>プレイヤー情報</h2>
      <table>
        <tr>
          <th>プレイヤー</th>
          <th>トータルpt</th>
          <th>持ち点</th>
          <th>親</th>
        </tr>
        <tr>
          <td><input type="text" id="nameA" class="player-name-input" value="A"></td>
          <td><input type="number" id="totalA" value="0" step="0.1"></td>
          <td><input type="number" id="holdA" value="25000" step="100"></td>
          <td><input type="checkbox" id="parentA"></td>
        </tr>
        <tr>
          <td><input type="text" id="nameB" class="player-name-input" value="B"></td>
          <td><input type="number" id="totalB" value="0" step="0.1"></td>
          <td><input type="number" id="holdB" value="25000" step="100"></td>
          <td><input type="checkbox" id="parentB"></td>
        </tr>
        <tr>
          <td><input type="text" id="nameC" class="player-name-input" value="C"></td>
          <td><input type="number" id="totalC" value="0" step="0.1"></td>
          <td><input type="number" id="holdC" value="25000" step="100"></td>
          <td><input type="checkbox" id="parentC"></td>
        </tr>
        <tr>
          <td><input type="text" id="nameD" class="player-name-input" value="D"></td>
          <td><input type="number" id="totalD" value="0" step="0.1"></td>
          <td><input type="number" id="holdD" value="25000" step="100"></td>
          <td><input type="checkbox" id="parentD"></td>
        </tr>
      </table>
    </div>
    <div class="settings-container">
      <h2>順位点設定</h2>
      <p>各順位の順位点を入力してください（例：1位:+50, 2位:+10, 3位:-10, 4位:-30）</p>
      <table>
        <tr>
          <th>1位</th>
          <th>2位</th>
          <th>3位</th>
          <th>4位</th>
        </tr>
        <tr>
          <td><input type="number" id="rank1" value="50"></td>
          <td><input type="number" id="rank2" value="10"></td>
          <td><input type="number" id="rank3" value="-10"></td>
          <td><input type="number" id="rank4" value="-30"></td>
        </tr>
      </table>
      <p>本場数: <input type="number" id="honba" value="0" min="0" step="1"> 本場</p>
      <p>供託（リーチ棒）本数: <input type="number" id="riichiSticks" value="0" min="0" step="1"> 本（1本=1000点）</p>
    </div>
  </div>

  <!-- ボタン -->
  <div class="button-container">
    <button onclick="doCalculate()">計算する</button>
    <button onclick="doReset()">リセット</button>
  </div>

  <!-- 結果表示 -->
  <h2>結果表示</h2>
  <p>
    各セルをの点数クリックすると、そのシナリオで和了った場合の詳細が右側に表示されます。<br>
    <strong><font color="#ff0000">間違った計算結果が表示される可能性もある為、あやしいときは詳細で計算内容が正しいことを確認してください。</font></strong>
  </p>
  <div class="result-container">
    <div id="resultArea"></div>
    <div id="detailArea"></div>
  </div>

  <!-- フッター -->
  <footer>
    ©2025
  </footer>

  <script>
    function getPlayerNames() {
      return {
        A: document.getElementById("nameA").value || "A",
        B: document.getElementById("nameB").value || "B",
        C: document.getElementById("nameC").value || "C",
        D: document.getElementById("nameD").value || "D"
      };
    }

    function getRankPoints() {
      return [
        parseFloat(document.getElementById("rank1").value),
        parseFloat(document.getElementById("rank2").value),
        parseFloat(document.getElementById("rank3").value),
        parseFloat(document.getElementById("rank4").value)
      ];
    }

    const PARENT_RON_POINTS = [
      1500, 2000, 2400, 2900, 3400, 3900, 4400, 4800, 5300, 5800, 6800, 7700, 8700,
      9600, 10600, 11600, 12000, 18000, 24000, 36000, 48000, 96000, 144000
    ];
    const PARENT_TSUMO_POINTS = [
      500, 700, 800, 1000, 1200, 1300, 1500, 1600, 1800, 2000, 2300, 2600, 2900,
      3200, 3600, 3900, 4000, 6000, 8000, 12000, 16000, 32000, 48000
    ];
    const CHILD_RON_POINTS = [
      1000, 1300, 1600, 2000, 2300, 2600, 2900, 3200, 3600, 3900, 4500, 5200, 5800,
      6400, 7100, 7700, 8000, 12000, 16000, 24000, 32000, 64000, 96000
    ];
    const CHILD_TSUMO_POINTS = [
      [300, 500], [400, 700], [400, 800], [500, 1000], [600, 1200], [700, 1300],
      [800, 1500], [800, 1600], [900, 1800], [1000, 2000], [1200, 2300], [1300, 2600],
      [1500, 2900], [1600, 3200], [1800, 3600], [2000, 3900], [2000, 4000],
      [3000, 6000], [4000, 8000], [6000, 12000], [8000, 16000], [16000, 32000],
      [24000, 48000]
    ];

    function calcFinalTotals(modHoldings, totals, rankPoints) {
      let playerNames = getPlayerNames();
      let players = ["A", "B", "C", "D"].map(p => {
        return { 
          key: p, 
          name: playerNames[p], 
          hold: modHoldings[p], 
          totalBefore: totals[p] 
        };
      });
      players.sort((a, b) => b.hold - a.hold);
      let currentRank = 1;
      for (let i = 0; i < players.length;) {
        let group = [players[i]];
        let j = i + 1;
        while (j < players.length && players[j].hold === players[i].hold) {
          group.push(players[j]);
          j++;
        }
        let groupSize = group.length;
        let sumRankPoints = 0;
        for (let k = 0; k < groupSize; k++) {
          sumRankPoints += rankPoints[currentRank - 1 + k];
        }
        let avgRankPoint = sumRankPoints / groupSize;
        group.forEach(player => {
          player.diff = (player.hold - 30000) / 1000;
          player.rank = currentRank;
          player.rankPoint = avgRankPoint;
          player.final = player.totalBefore + player.diff + player.rankPoint;
        });
        currentRank += groupSize;
        i = j;
      }
      return players;
    }

    function getMinPointsToWin(totals, holds, winner, method, target, parentFlags, honba, riichiSticks) {
      let pointsList;
      if (method === "ron") {
        pointsList = parentFlags[winner] ? PARENT_RON_POINTS : CHILD_RON_POINTS;
        pointsList = [0, ...pointsList];
      } else if (method === "tsumo") {
        if (parentFlags[winner]) {
          pointsList = [0, ...PARENT_TSUMO_POINTS];
        } else {
          pointsList = [[0, 0], ...CHILD_TSUMO_POINTS];
        }
      }

      for (let point of pointsList) {
        let X, Y;
        if (method === "tsumo" && !parentFlags[winner]) {
          X = point[0];
          Y = point[1];
        } else {
          X = point;
        }
        let newHolds = Object.assign({}, holds);
        if (method === "ron") {
          if (X > 0) { // 和了点が0でない場合のみ処理
            let ronPoints = X + honba * 300;
            newHolds[winner] += ronPoints;
            newHolds[target] -= ronPoints;
            newHolds[winner] += riichiSticks * 1000; // 供託を加算
          }
        } else if (method === "tsumo") {
          if ((parentFlags[winner] && X > 0) || (!parentFlags[winner] && (X > 0 || Y > 0))) { // 和了点が0でない場合のみ処理
            if (parentFlags[winner]) {
              let tsumoPoints = X + honba * 100;
              newHolds[winner] += tsumoPoints * 3;
              ["A", "B", "C", "D"].forEach(p => {
                if (p !== winner) newHolds[p] -= tsumoPoints;
              });
            } else {
              let childPay = X + honba * 100;
              let parentPay = Y + honba * 100;
              let parent = Object.entries(parentFlags).find(([k, v]) => v)[0];
              newHolds[winner] += childPay * 2 + parentPay;
              ["A", "B", "C", "D"].forEach(p => {
                if (p !== winner) {
                  if (p === parent) {
                    newHolds[p] -= parentPay;
                  } else {
                    newHolds[p] -= childPay;
                  }
                }
              });
            }
            newHolds[winner] += riichiSticks * 1000; // 供託を加算
          }
        }

        let players = calcFinalTotals(newHolds, totals, getRankPoints());
        let winFinal = players.find(p => p.key === winner).final;
        let isTop = players.every(p => p.key === winner || p.final < winFinal);
        if (isTop) {
          if (method === "tsumo" && !parentFlags[winner]) {
            if (X === 0 && Y === 0) {
              return "オールOK";
            } else {
              return `${X} / ${Y}`;
            }
          } else if (X === 0) {
            return "オールOK";
          } else {
            return X;
          }
        }
      }
      return "優勝不可";
    }

    function getMinPointsForTop2(totals, holds, winner, method, target, parentFlags, honba, riichiSticks) {
      let pointsList;
      if (method === "ron") {
        pointsList = parentFlags[winner] ? PARENT_RON_POINTS : CHILD_RON_POINTS;
        pointsList = [0, ...pointsList];
      } else if (method === "tsumo") {
        if (parentFlags[winner]) {
          pointsList = [0, ...PARENT_TSUMO_POINTS];
        } else {
          pointsList = [[0, 0], ...CHILD_TSUMO_POINTS];
        }
      }

      for (let point of pointsList) {
        let X, Y;
        if (method === "tsumo" && !parentFlags[winner]) {
          X = point[0];
          Y = point[1];
        } else {
          X = point;
        }
        let newHolds = Object.assign({}, holds);
        if (method === "ron") {
          if (X > 0) { // 和了点が0でない場合のみ処理
            let ronPoints = X + honba * 300;
            newHolds[winner] += ronPoints;
            newHolds[target] -= ronPoints;
            newHolds[winner] += riichiSticks * 1000; // 供託を加算
          }
        } else if (method === "tsumo") {
          if ((parentFlags[winner] && X > 0) || (!parentFlags[winner] && (X > 0 || Y > 0))) { // 和了点が0でない場合のみ処理
            if (parentFlags[winner]) {
              let tsumoPoints = X + honba * 100;
              newHolds[winner] += tsumoPoints * 3;
              ["A", "B", "C", "D"].forEach(p => {
                if (p !== winner) newHolds[p] -= tsumoPoints;
              });
            } else {
              let childPay = X + honba * 100;
              let parentPay = Y + honba * 100;
              let parent = Object.entries(parentFlags).find(([k, v]) => v)[0];
              newHolds[winner] += childPay * 2 + parentPay;
              ["A", "B", "C", "D"].forEach(p => {
                if (p !== winner) {
                  if (p === parent) {
                    newHolds[p] -= parentPay;
                  } else {
                    newHolds[p] -= childPay;
                  }
                }
              });
            }
            newHolds[winner] += riichiSticks * 1000; // 供託を加算
          }
        }

        let players = calcFinalTotals(newHolds, totals, getRankPoints());
        let winFinal = players.find(p => p.key === winner).final;
        let higherCount = players.filter(p => p.key !== winner && p.final < winFinal).length;
        if (higherCount >= 2) {
          if (method === "tsumo" && !parentFlags[winner]) {
            if (X === 0 && Y === 0) {
              return "オールOK";
            } else {
              return `${X} / ${Y}`;
            }
          } else if (X === 0) {
            return "オールOK";
          } else {
            return X;
          }
        }
      }
      return "2位以内不可";
    }

    function simulateScenario(winner, method, target, scoreVal, totals, holds, parentFlags, honba, riichiSticks, rankPoints) {
      let newHolds = Object.assign({}, holds);
      let X, Y;
      if (method === "ron") {
        X = Number(scoreVal);
        if (X > 0) { // 和了点が0でない場合のみ処理
          let ronPoints = X + honba * 300;
          newHolds[winner] += ronPoints;
          newHolds[target] -= ronPoints;
          newHolds[winner] += riichiSticks * 1000; // 供託を加算
        }
      } else if (method === "tsumo") {
        if (parentFlags[winner]) {
          X = Number(scoreVal);
          if (X > 0) { // 和了点が0でない場合のみ処理
            let tsumoPoints = X + honba * 100;
            newHolds[winner] += tsumoPoints * 3;
            ["A", "B", "C", "D"].forEach(p => {
              if (p !== winner) newHolds[p] -= tsumoPoints;
            });
            newHolds[winner] += riichiSticks * 1000; // 供託を加算
          }
        } else {
          let parts = scoreVal.split("/");
          X = Number(parts[0].trim());
          Y = Number(parts[1].trim());
          if (X > 0 || Y > 0) { // 和了点が0でない場合のみ処理
            let childPay = X + honba * 100;
            let parentPay = Y + honba * 100;
            let parent = Object.entries(parentFlags).find(([k, v]) => v)[0];
            newHolds[winner] += childPay * 2 + parentPay;
            ["A", "B", "C", "D"].forEach(p => {
              if (p !== winner) {
                if (p === parent) {
                  newHolds[p] -= parentPay;
                } else {
                  newHolds[p] -= childPay;
                }
              }
            });
            newHolds[winner] += riichiSticks * 1000; // 供託を加算
          }
        }
      }
      return calcFinalTotals(newHolds, totals, rankPoints);
    }

    function showDetail(winnerKey, method, targetKey, scoreVal) {
      let playerNames = getPlayerNames();
      let winner = playerNames[winnerKey];
      let target = targetKey ? playerNames[targetKey] : "";
      
      let totals = {
        A: parseFloat(document.getElementById("totalA").value),
        B: parseFloat(document.getElementById("totalB").value),
        C: parseFloat(document.getElementById("totalC").value),
        D: parseFloat(document.getElementById("totalD").value)
      };
      let holds = {
        A: parseInt(document.getElementById("holdA").value),
        B: parseInt(document.getElementById("holdB").value),
        C: parseInt(document.getElementById("holdC").value),
        D: parseInt(document.getElementById("holdD").value)
      };
      let parentFlags = {
        A: document.getElementById("parentA").checked,
        B: document.getElementById("parentB").checked,
        C: document.getElementById("parentC").checked,
        D: document.getElementById("parentD").checked
      };
      let honba = parseInt(document.getElementById("honba").value);
      let riichiSticks = parseInt(document.getElementById("riichiSticks").value);
      let rankPoints = getRankPoints();

      let players = simulateScenario(winnerKey, method, targetKey, scoreVal, totals, holds, parentFlags, honba, riichiSticks, rankPoints);
      let detailHtml = "<h3>【詳細】" + winner + "が" + (method === "ron" ? ("ロン from " + target) : (method === "tsumo" ? "ツモ" : "")) + "で" + scoreVal + "点和了った場合</h3>";
      detailHtml += "<table><tr><th>プレイヤー</th><th>新持ち点</th><th>持ち点差</th><th>順位点</th><th>半荘得失点</th><th>前回トータルpt</th><th>合計</th></tr>";
      players.sort((a, b) => a.key.localeCompare(b.key));
      players.forEach(p => {
        let diff = ((p.hold - 30000) / 1000).toFixed(1);
        detailHtml += `<tr>
          <td>${p.name}</td>
          <td>${p.hold}</td>
          <td>${diff}</td>
          <td>${p.rankPoint.toFixed(1)}</td>
          <td>${(p.diff + p.rankPoint).toFixed(1)}</td>
          <td>${p.totalBefore}</td>
          <td>${p.final.toFixed(1)}</td>
        </tr>`;
      });
      detailHtml += "</table>";
      document.getElementById("detailArea").innerHTML = detailHtml;
    }

    function doCalculate() {
      let playerNames = getPlayerNames();
      let totals = {
        A: parseFloat(document.getElementById("totalA").value),
        B: parseFloat(document.getElementById("totalB").value),
        C: parseFloat(document.getElementById("totalC").value),
        D: parseFloat(document.getElementById("totalD").value)
      };
      let holds = {
        A: parseInt(document.getElementById("holdA").value),
        B: parseInt(document.getElementById("holdB").value),
        C: parseInt(document.getElementById("holdC").value),
        D: parseInt(document.getElementById("holdD").value)
      };
      let parentFlags = {
        A: document.getElementById("parentA").checked,
        B: document.getElementById("parentB").checked,
        C: document.getElementById("parentC").checked,
        D: document.getElementById("parentD").checked
      };
      let honba = parseInt(document.getElementById("honba").value);
      let riichiSticks = parseInt(document.getElementById("riichiSticks").value);
      let rankPoints = getRankPoints();

      let errorMessages = "";
      let totalSum = Object.values(totals).reduce((a, b) => a + b, 0);
      if (Math.abs(totalSum) > 0.0001) { // 許容誤差を0.0001に設定
        errorMessages += `<p class="warning">警告：トータルポイントの合計が0ではありません（合計: ${totalSum.toFixed(2)}）。</p>`;
      }
      let holdSum = Object.values(holds).reduce((a, b) => a + b, 0);
      if (holdSum + riichiSticks * 1000 !== 100000) {
        errorMessages += `<p class="warning">警告：持ち点の合計が100,000点ではありません（合計: ${holdSum + riichiSticks * 1000}）。</p>`;
      }
      let pCount = Object.values(parentFlags).filter(v => v).length;
      if (pCount !== 1) {
        errorMessages += `<p class="error">エラー：親は必ず1人だけチェックしてください（現在 ${pCount} 人）。</p>`;
        document.getElementById("resultArea").innerHTML = errorMessages;
        return;
      }

      let players = ["A", "B", "C", "D"];

      let winResults = {};
      players.forEach(w => {
        winResults[w] = { ron: {}, tsumo: null };
        players.forEach(l => {
          if (l !== w) {
            let res = getMinPointsToWin(totals, holds, w, "ron", l, parentFlags, honba, riichiSticks);
            winResults[w].ron[l] = (res === "優勝不可" || res === "オールOK") 
              ? res 
              : `<a href="#" onclick="showDetail('${w}','ron','${l}','${res}')" >${res}点</a>`;
          }
        });
        let tsumoRes = getMinPointsToWin(totals, holds, w, "tsumo", "", parentFlags, honba, riichiSticks);
        winResults[w].tsumo = (tsumoRes === "優勝不可" || tsumoRes === "オールOK") 
          ? tsumoRes 
          : `<a href="#" onclick="showDetail('${w}','tsumo','','${tsumoRes}')" >${tsumoRes}</a>`;
      });

      let top2Results = {};
      players.forEach(w => {
        top2Results[w] = { ron: {}, tsumo: null };
        players.forEach(l => {
          if (l !== w) {
            let res = getMinPointsForTop2(totals, holds, w, "ron", l, parentFlags, honba, riichiSticks);
            top2Results[w].ron[l] = (res === "2位以内不可" || res === "オールOK") 
              ? res 
              : `<a href="#" onclick="showDetail('${w}','ron','${l}','${res}')" >${res}点</a>`;
          }
        });
        let tsumoRes = getMinPointsForTop2(totals, holds, w, "tsumo", "", parentFlags, honba, riichiSticks);
        top2Results[w].tsumo = (tsumoRes === "2位以内不可" || tsumoRes === "オールOK") 
          ? tsumoRes 
          : `<a href="#" onclick="showDetail('${w}','tsumo','','${tsumoRes}')" >${tsumoRes}</a>`;
      });

      let winHtml = "<h3>優勝するために必要な最小和了点数</h3><table class='resultTable'><tr><th>和了者</th>";
      players.forEach(p => {
        winHtml += `<th>ロン from ${playerNames[p]}</th>`;
      });
      winHtml += "<th>ツモ</th></tr>";
      players.forEach(w => {
        winHtml += `<tr><th>${playerNames[w]}</th>`;
        players.forEach(p => {
          if (p === w) {
            winHtml += "<td>―</td>";
          } else {
            winHtml += `<td>${winResults[w].ron[p]}</td>`;
          }
        });
        winHtml += `<td>${winResults[w].tsumo}</td></tr>`;
      });
      winHtml += "</table>";

      let top2Html = "<h3>2位以内に入るために必要な最小和了点数</h3><table class='resultTable'><tr><th>和了者</th>";
      players.forEach(p => {
        top2Html += `<th>ロン from ${playerNames[p]}</th>`;
      });
      top2Html += "<th>ツモ</th></tr>";
      players.forEach(w => {
        top2Html += `<tr><th>${playerNames[w]}</th>`;
        players.forEach(p => {
          if (p === w) {
            top2Html += "<td>―</td>";
          } else {
            top2Html += `<td>${top2Results[w].ron[p]}</td>`;
          }
        });
        top2Html += `<td>${top2Results[w].tsumo}</td></tr>`;
      });
      top2Html += "</table>";

      document.getElementById("resultArea").innerHTML = errorMessages + winHtml + top2Html;
    }

    function doReset() {
      document.getElementById("nameA").value = "A";
      document.getElementById("nameB").value = "B";
      document.getElementById("nameC").value = "C";
      document.getElementById("nameD").value = "D";
      document.getElementById("totalA").value = "0";
      document.getElementById("totalB").value = "0";
      document.getElementById("totalC").value = "0";
      document.getElementById("totalD").value = "0";
      document.getElementById("holdA").value = "25000";
      document.getElementById("holdB").value = "25000";
      document.getElementById("holdC").value = "25000";
      document.getElementById("holdD").value = "25000";
      document.getElementById("parentA").checked = false;
      document.getElementById("parentB").checked = false;
      document.getElementById("parentC").checked = false;
      document.getElementById("parentD").checked = false;
      document.getElementById("rank1").value = "50";
      document.getElementById("rank2").value = "10";
      document.getElementById("rank3").value = "-10";
      document.getElementById("rank4").value = "-30";
      document.getElementById("honba").value = "0";
      document.getElementById("riichiSticks").value = "0";
      document.getElementById("resultArea").innerHTML = "";
      document.getElementById("detailArea").innerHTML = "";
    }
  </script>
</body>
</html>
